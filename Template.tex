% Copyright © 2013 Martin Ueding <dev@martin-ueding.de>

\input{../header.tex}

\usepackage{placeins}
\usepackage{minted}
\usepackage{multicol}

\ihead{physik313 – Versuch 8}
\ifoot{Lino Lemmer, Martin Ueding}

\subject{Praktikumsprotokoll}
\title{Mikroprozessor}
\subtitle{physik313 – Versuch 8}
\author{
	Lino Lemmer
    \footnote{\href{mailto:s6lilemm@uni-bonn.de}{s6lilemm@uni-bonn.de}}
	\and
	Martin Ueding
    \footnote{\href{mailto:mu@martin-ueding.de}{mu@martin-ueding.de}}
}

%\setcounter{tocdepth}{2}

\newcommand\fT{f_\text{T}}
\newcommand\IB{I_\text{B}}
\newcommand\IC{I_\text{C}}
\newcommand\ID{I_\text{D}}
\newcommand\IE{I_\text{E}}
\newcommand\IS{I_\text{S}}
\newcommand\RC{R_\text{C}}
\newcommand\RD{R_\text{D}}
\newcommand\RE{R_\text{E}}
\newcommand\UBE{U_\text{BE}}
\newcommand\UB{U_\text{B}}
\newcommand\UCE{U_\text{CE}}
\newcommand\UC{U_\text{C}}
\newcommand\UD{U_\text{D}}
\newcommand\UDS{U_\text{DS}}
\newcommand\UE{U_\text{E}}
\newcommand\UGS{U_\text{GS}}
\newcommand\UG{U_\text{G}}
\newcommand\Uin{U_\text{in}}
\newcommand\Uout{U_\text{out}}

\newcommand\UEH{U_\text{E H}}
\newcommand\UEL{U_\text{E L}}
\newcommand\UH{U_\text{H}}
\newcommand\UL{U_\text{L}}
\newcommand\UQH{U_\text{Q H}}
\newcommand\UQL{U_\text{Q L}}

\newcommand\mand {\wedge}
\newcommand\mhigh{\top}
\newcommand\mlow {\bot}
\newcommand\mnand{\bar\wedge}
\newcommand\mnor {\bar\vee}
\newcommand\mnot {\neg}
\newcommand\mor  {\vee}
\newcommand\mxor {\veebar}
\newcommand\tand {\textsc{and}}
\newcommand\thigh{\textsc{high}}
\newcommand\tlow {\textsc{low}}
\newcommand\tnand{\textsc{nand}}
\newcommand\tnor {\textsc{nor}}
\newcommand\tnot {\textsc{not}}
\newcommand\tor  {\textsc{or}}
\newcommand\txor {\textsc{xor}}

\begin{document}

\maketitle

\vfill

Der \LaTeX-Quelltext zu allen Protokollen in diesem Praktikum kann auf
\ref{it:mu} eingesehen werden. Die Quellen für dieses Protokoll können auf
\ref{it:github/alles} eingesehen werden. Die \LaTeX-Datei wird aus
\ref{it:github/template} generiert.

\begin{enumerate}
	\item
		\label{it:mu}
		\url{http://martin-ueding.de/de/university/physik313/}
	\item
		\label{it:github/alles}
		\url{https://github.com/martin-ueding/physik313-8/}
	\item
		\label{it:github/template}
		\url{https://github.com/martin-ueding/physik313-8/blob/master/Template.tex}
\end{enumerate}

\newpage
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                 Einleitung                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\FloatBarrier
\section{Einleitung}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  Theorie                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\FloatBarrier
\section{Theorie}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  Aufgaben                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\FloatBarrier
\section{Aufgaben}

\subsection{Aufgabe A}

\begin{problem}
	Wandeln Sie die zwei nachfolgenden Dualzahlen in das Hexadezimal- und das
	Dezimalsystem um:
	\begin{gather*}
		1101\,1111\,0010\,1110_2 \\
		1111\,1111_2
	\end{gather*}
\end{problem}

An dieser Stelle möchte ich mich als guter Programmierer meiner Faulheit
bedienen (Aussage von Larry Wall, \cite{threevirtues.com}). Daher benutze ich
Python 3, um die Zahlen zu verrechnen. Mir ist durchaus bekannt, wie man die
Zahlen umrechnet, jedoch möchte ich meine Zeit lieber für die interessanten
Teile dieses Versuchs aufwenden.

\begin{minted}{pycon}
>>> 0b1101111100101110
57134
\end{minted}

\subsection{Aufgabe B}

\begin{problem}
	Wandeln Sie die nachfolgenden Dezimalzahlen in Binär- und Hexadezimalzahlen
	um:
	\[
		2115_{10}
	\]
\end{problem}

\begin{minted}{pycon}
>>> bin(2115)
'0b100001000011'
\end{minted}

\subsection{Aufgabe C}

\begin{problem}
	Wandeln Sie die nachfolgenden Hexadezimalzahl in Binär- und
	Dezimaldarstellung um:
	\[
		\mathrm{B75F}_{16}
	\]
\end{problem}

\begin{minted}{pycon}
>>> 0xb75f
46943
>>> bin(_)
'0b1011011101011111'
\end{minted}

\subsection{Aufgabe D}

\begin{problem}
	Führen Sie die nachfolgenden Operationen zwischen Dualzahlen durch:
\end{problem}

\paragraph{Addition}

\begin{minted}{pycon}
>>> bin(0b01011011 + 0b01101011)
'0b11000110'
>>> bin(0b11111111 + 0b00000001)
'0b100000000'
\end{minted}

\paragraph{Subtraktion}

\begin{minted}{pycon}
>>> bin(0b11000000 - 0b10110101)
'0b1011'
\end{minted}

\paragraph{Multiplikation}

\begin{minted}{pycon}
>>> bin(0b1101 * 0b1001)
'0b1110101'
\end{minted}

\paragraph{Division}

Hier entsteht offensichtlich ein Rest, so dass ganzzahlige Division benutzt
werden muss:

\begin{minted}{pycon}
>>> bin(0b1110111 / 0b101)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'float' object cannot be interpreted as an integer
>>> 0b1110111 / 0b101
23.8
>>> bin(0b1110111 // 0b101)
'0b10111'
\end{minted}

\subsection{Aufgabe E}

\begin{problem}
	Erklären Sie den Unterschied von ROM und RAM. Wo liegen die Vorteile der
	beiden Typen?
\end{problem}

ROM ist nur lesbar, meistens langsam jedoch ohne Stromversorgung stabil. RAM
ist auch schreibbar, sehr schnell, jedoch gehen ohne kontinuierliche
Stromversorgung die Daten verloren.

\subsection{Aufgabe F}

\begin{problem}
	Kann man mit Digitalrechnern analoge Signale verarbeiten? Was brauchen Sie
	hierfür? Wodurch wird die Genaugikeit begrenzt?
\end{problem}

Man braucht ADC, die jedoch bei $b$ Bytes pro Messwert nur $2^b$ Stufen
abbilden können.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                Durchführung                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Durchführung}

\subsection{Umgang mit System 3}

\subsection{Versuchsaufgabe 5}

\subsubsection{Beschreiben der Funktionen}

\begin{problem}
	Beschreiben Sie die Funktionen des Programmes.
\end{problem}

Um ein Gefühl für das Programm zu bekommen, und um es schon vorher zuhause zu
testen, habe ich es in C++ nachgebaut. Dabei habe ich ausgenutzt, dass C
eigentlich nur Assembler mit Makros ist und auch über ein \texttt{goto}
verfügt. Die Ausgabe erfolgt in eine Textdatei.

\inputminted[fontsize=\small, linenos]{cpp}{../Prototypen/saegezahn.cpp}

Die \textit{if}-Abfrage musste nur rein, damit das Programm auch terminiert.
Die Ausgabe ist wie folgt, von oben nach unten, von links nach rechts:

\begin{multicols}{9}
	\inputminted[fontsize=\footnotesize]{text}{saegezahn.txt}
\end{multicols}

Zu erkennen ist der Sägezahn, der durch den (hier gewollten) Überlauf zustande
kommt.

\subsubsection{Ändern der Periode}

\begin{problem}
	Ändern Sie das Programm so, dass die Möglichkeit besteht, über die
	B-Register die Periodendauer variabel zu verlängern.
\end{problem}

Um die Periode zu ändern, inkrementieren wir nicht, sondern addieren einen Wert
aus Register b. Dies habe ich in folgendem, leicht modifiziertem Programm
gemacht:

\inputminted[fontsize=\small, linenos]{cpp}{../Prototypen/d.cpp}

\begin{multicols}{9}
	\inputminted[fontsize=\footnotesize]{text}{d.txt}
\end{multicols}

\subsubsection{Anderes Signal}

\begin{problem}
	Versuchen [S]ie nun mit Hilfe des DACs ein anderes Signal, wie z.\,B. ein
	Dreieck- oder Rechtecksignal zu erzeugen. Lassen Sie dabei Ihrer Phantasie
	freien Lauf.
\end{problem}

Für ein Rechtecksignal könnte man einen Zähler verwenden, und dann die Ausgabe
umschalten, wenn dieser heruntergezählt ist. Ich möchte hier ein wenig binäre
Logik benutzen und einen überlaufenden Zähler benutzen, jedoch eine der Stellen
als Ausgabe nutzen.

\inputminted[fontsize=\small, linenos]{cpp}{../Prototypen/e.cpp}

\begin{multicols}{9}
	\inputminted[fontsize=\footnotesize]{text}{e.txt}
\end{multicols}

\subsubsection{Bit überprüfen}

\begin{problem}
	Überlegen Sie sich ein Programm, welches in der Lage ist zu erkennen, ob
	das 4.te Bit des B-Registers gesetzt ist. Ist das 4te Bit gesetzt (also
	„1“), so soll das gesamte X-Register der LED Matrix aufleuchten.
\end{problem}

Um ein Bit zu überprüfen, schaue ich mit einer Art Schablone und \txor, ob das
entsprechende Bit gesetzt ist. Mit einem Sprungbefehl, der mit 0 vergleicht,
springe ich an die entsprechende Stelle und setze meine Ausgabe entsprechend.

\inputminted[fontsize=\small, linenos]{cpp}{../Prototypen/f.cpp}

\begin{multicols}{9}
	\inputminted[fontsize=\footnotesize]{text}{f.txt}
\end{multicols}

Diese Ausgabe sind binär nur Einsen, also wurde das entsprechende Bit gefunden.
Bei FF als Eingabe war dies auch zu erwarten.

\subsubsection{Multiplikation}

\begin{problem}
	Schreiben Sie ein Programm zur Multiplikation zweiter 8-Bit-Zahlen. Der
	Multiplikand und der Multiplikator sollen an den A- und B-Registern
	eingegeben werden. Das Ergebnis (16 Bit) soll von zwei Registern der LED
	Matrix (X und R) angezeigt wwerden. HInweis: Nutzen Sie die
	Doppelgenauigkeits-Arithmetikbefehle.
\end{problem}

Für diese Aufgabe wähle ich einen einfachen Algorithmus, und zwar:
\[
	a \cdot b = \sum_{i = 1}^{a} b
\]

Das Problem ist, dass negative Zahlen so nicht berücksichtigt werden.

\inputminted[fontsize=\small, linenos]{cpp}{../Prototypen/g.cpp}

Die Ausgabe in den zwei Registern ist, wie erwartet:

\begin{multicols}{9}
	\inputminted[fontsize=\footnotesize]{text}{g.txt}
\end{multicols}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  Literatur                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\FloatBarrier
\IfFileExists{\bibliographyfile}{
	\bibliography{\bibliographyfile}
}{}

\end{document}

% vim: spell spelllang=de tw=79
