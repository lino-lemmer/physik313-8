% Copyright © 2013 Martin Ueding <dev@martin-ueding.de>

\input{../header.tex}

\usepackage{placeins}
\usepackage{minted}
\usepackage{multicol}

\ihead{physik313 – Versuch 8}
\ifoot{Lino Lemmer, Martin Ueding}

\subject{Praktikumsprotokoll}
\title{Mikroprozessor}
\subtitle{physik313 – Versuch 8}
\author{
	Lino Lemmer
    \footnote{\href{mailto:s6lilemm@uni-bonn.de}{s6lilemm@uni-bonn.de}}
	\and
	Martin Ueding
    \footnote{\href{mailto:mu@martin-ueding.de}{mu@martin-ueding.de}}
}

%\setcounter{tocdepth}{2}

\newcommand\fT{f_\text{T}}
\newcommand\IB{I_\text{B}}
\newcommand\IC{I_\text{C}}
\newcommand\ID{I_\text{D}}
\newcommand\IE{I_\text{E}}
\newcommand\IS{I_\text{S}}
\newcommand\RC{R_\text{C}}
\newcommand\RD{R_\text{D}}
\newcommand\RE{R_\text{E}}
\newcommand\UBE{U_\text{BE}}
\newcommand\UB{U_\text{B}}
\newcommand\UCE{U_\text{CE}}
\newcommand\UC{U_\text{C}}
\newcommand\UD{U_\text{D}}
\newcommand\UDS{U_\text{DS}}
\newcommand\UE{U_\text{E}}
\newcommand\UGS{U_\text{GS}}
\newcommand\UG{U_\text{G}}
\newcommand\Uin{U_\text{in}}
\newcommand\Uout{U_\text{out}}

\newcommand\UEH{U_\text{E H}}
\newcommand\UEL{U_\text{E L}}
\newcommand\UH{U_\text{H}}
\newcommand\UL{U_\text{L}}
\newcommand\UQH{U_\text{Q H}}
\newcommand\UQL{U_\text{Q L}}

\newcommand\mand {\wedge}
\newcommand\mhigh{\top}
\newcommand\mlow {\bot}
\newcommand\mnand{\bar\wedge}
\newcommand\mnor {\bar\vee}
\newcommand\mnot {\neg}
\newcommand\mor  {\vee}
\newcommand\mxor {\veebar}
\newcommand\tand {\textsc{and}}
\newcommand\thigh{\textsc{high}}
\newcommand\tlow {\textsc{low}}
\newcommand\tnand{\textsc{nand}}
\newcommand\tnor {\textsc{nor}}
\newcommand\tnot {\textsc{not}}
\newcommand\tor  {\textsc{or}}
\newcommand\txor {\textsc{xor}}

\begin{document}

\maketitle

\vfill

Der \LaTeX-Quelltext zu allen Protokollen in diesem Praktikum kann auf
\ref{it:mu} eingesehen werden. Die Quellen für dieses Protokoll können auf
\ref{it:github/alles} eingesehen werden. Die \LaTeX-Datei wird aus
\ref{it:github/template} generiert.

\begin{enumerate}
	\item
		\label{it:mu}
		\url{http://martin-ueding.de/de/university/physik313/}
	\item
		\label{it:github/alles}
		\url{https://github.com/martin-ueding/physik313-8/}
	\item
		\label{it:github/template}
		\url{https://github.com/martin-ueding/physik313-8/blob/master/Template.tex}
\end{enumerate}

\newpage
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                 Einleitung                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\FloatBarrier
\section{Einleitung}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  Theorie                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\FloatBarrier
\section{Theorie}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  Aufgaben                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\FloatBarrier
\section{Aufgaben}

\subsection{Aufgabe A}

\begin{problem}
	Wandeln Sie die zwei nachfolgenden Dualzahlen in das Hexadezimal- und das
	Dezimalsystem um:
	\begin{gather*}
		1101\,1111\,0010\,1110_2 \\
		1111\,1111_2
	\end{gather*}
\end{problem}

An dieser Stelle möchte ich mich als guter Programmierer meiner Faulheit
bedienen (Aussage von Larry Wall, \cite{threevirtues.com}). Daher benutze ich
Python 3, um die Zahlen zu verrechnen. Mir ist durchaus bekannt, wie man die
Zahlen umrechnet, jedoch möchte ich meine Zeit lieber für die interessanten
Teile dieses Versuchs aufwenden.

\begin{minted}{pycon}
>>> 0b1101111100101110
57134
\end{minted}

\subsection{Aufgabe B}

\begin{problem}
	Wandeln Sie die nachfolgenden Dezimalzahlen in Binär- und Hexadezimalzahlen
	um:
	\[
		2115_{10}
	\]
\end{problem}

\begin{minted}{pycon}
>>> bin(2115)
'0b100001000011'
\end{minted}

\subsection{Aufgabe C}

\begin{problem}
	Wandeln Sie die nachfolgenden Hexadezimalzahl in Binär- und
	Dezimaldarstellung um:
	\[
		\mathrm{B75F}_{16}
	\]
\end{problem}

\begin{minted}{pycon}
>>> 0xb75f
46943
>>> bin(_)
'0b1011011101011111'
\end{minted}

\subsection{Aufgabe D}

\begin{problem}
	Führen Sie die nachfolgenden Operationen zwischen Dualzahlen durch:
\end{problem}

\paragraph{Addition}

\begin{minted}{pycon}
>>> bin(0b01011011 + 0b01101011)
'0b11000110'
>>> bin(0b11111111 + 0b00000001)
'0b100000000'
\end{minted}

\paragraph{Subtraktion}

\begin{minted}{pycon}
>>> bin(0b11000000 - 0b10110101)
'0b1011'
\end{minted}

\paragraph{Multiplikation}

\begin{minted}{pycon}
>>> bin(0b1101 * 0b1001)
'0b1110101'
\end{minted}

\paragraph{Division}

Hier entsteht offensichtlich ein Rest, so dass ganzzahlige Division benutzt
werden muss:

\begin{minted}{pycon}
>>> bin(0b1110111 / 0b101)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'float' object cannot be interpreted as an integer
>>> 0b1110111 / 0b101
23.8
>>> bin(0b1110111 // 0b101)
'0b10111'
\end{minted}

\subsection{Aufgabe E}

\begin{problem}
	Erklären Sie den Unterschied von ROM und RAM. Wo liegen die Vorteile der
	beiden Typen?
\end{problem}

ROM ist nur lesbar, meistens langsam jedoch ohne Stromversorgung stabil. RAM
ist auch schreibbar, sehr schnell, jedoch gehen ohne kontinuierliche
Stromversorgung die Daten verloren.

\subsection{Aufgabe F}

\begin{problem}
	Kann man mit Digitalrechnern analoge Signale verarbeiten? Was brauchen Sie
	hierfür? Wodurch wird die Genaugikeit begrenzt?
\end{problem}

Man braucht ADC, die jedoch bei $b$ Bytes pro Messwert nur $2^b$ Stufen
abbilden können.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                Durchführung                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Durchführung}

\subsection{Umgang mit System 3}

\subsection{Versuchsaufgabe 5}

\subsubsection{Beschreiben der Funktionen}

\begin{problem}
	Beschreiben Sie die Funktionen des Programmes.
\end{problem}

Um ein Gefühl für das Programm zu bekommen, und um es schon vorher zuhause zu
testen, habe ich es in C++ nachgebaut. Dabei habe ich ausgenutzt, dass C
eigentlich nur Assembler mit Makros ist und auch über ein \texttt{goto}
verfügt. Die Ausgabe erfolgt in eine Textdatei.

\inputminted[fontsize=\small, linenos]{cpp}{../Prototypen/saegezahn.cpp}

Die \texttt{if}-Abfrage musste nur rein, damit das Programm auch terminiert.
Die Ausgabe ist wie folgt, von oben nach unten, von links nach rechts:

\begin{multicols}{9}
	\inputminted[fontsize=\footnotesize]{text}{saegezahn.txt}
\end{multicols}

Zu erkennen ist der Sägezahn, der durch den (hier gewollten) Überlauf zustande
kommt.

\paragraph{Konvertieren zu Assembly}

Um so richtig zu verstehen und zu dokumentieren, wie ich ein derartiges
Programm in 8080-Assembly übersetze, übersetze ich dieses Programm, das ich vom
Assembly abgelesen habe, wieder zurück in Assembly und dokumentiere dabei genau
die Schritte, die ich gemacht habe.

Zuerst muss die \texttt{0x00} in das Register A geschrieben werden. Dazu
benutze ich den Befehl \texttt{MVI~r}. Dieser hat einen Maschinencode von
\texttt{0b00ddd110}. Dabei ist das Ziel („Destination“, „d“) das Register A, der
Akkumulator. In der letzten Seite ist dessen Adresse mit 0b111 angegeben. Somit
setze ich meinen Befehl zusammen: \texttt{0b00111110} und noch das \texttt{0x00}.
Die erste Zahl lasse ich Python nach Hex konvertieren und erhalte
\texttt{0x3e}. Dies ist meine Zeile \texttt{0x00}.

Als nächstes kommt die Erhöhung von A. DAzu benutze ich den Befehl
\texttt{INR~r}. Dessen Maschinencode ist \texttt{0b00ddd100}, wobei ich wieder
\texttt{0b111} als Ziel einsetze. Konvertiert ist das ganze dann \texttt{0x3c}.

Jetzt folgt die Ausgabe auf den DAC-Wandler. Das Ausgabekommando ist
\texttt{OUT} und bekommt als zweites Byte das Zielregister. Dieses ist
\texttt{0x04}. Also \texttt{0xd3~0x04}.

Zuletzt kommt der Sprung zurück in Zeile \texttt{0x02}. Dazu benutze ich
\texttt{JMP}. Warum dieser Befehl zwei Bytes bekommt, und nicht nur ein Byte,
ist mir (noch) nicht klar. Das erste Byte ist jedenfalls die Zieladresse, das
Zweite ist im Programm aus der Aufgabenstellung einfach \texttt{0x00}. Dann
lasse ich das auch so.

So sieht das fertige Programm aus:

\inputminted[fontsize=\small, linenos]{text}{../Assembly/a.s}

Es ist genau gleich mit der Aufgabenstellung, so dass die obige Erklärung
wahrscheinlich richtig ist.

\subsubsection{Ändern der Periode}

\begin{problem}
	Ändern Sie das Programm so, dass die Möglichkeit besteht, über die
	B-Register die Periodendauer variabel zu verlängern.
\end{problem}

Um die Periode zu ändern, inkrementieren wir nicht, sondern addieren einen Wert
aus Register b. Dies habe ich in folgendem, leicht modifiziertem Programm
gemacht:

\inputminted[fontsize=\small, linenos]{cpp}{../Prototypen/d.cpp}

\begin{multicols}{9}
	\inputminted[fontsize=\footnotesize]{text}{d.txt}
\end{multicols}

Dieses Programm habe ich ähnlich der Vorgehensweise aus dem vorherigen
Abschnitt übersetzt:

\inputminted[fontsize=\small, linenos]{text}{../Assembly/a.s}

\subsubsection{Anderes Signal}

\begin{problem}
	Versuchen [S]ie nun mit Hilfe des DACs ein anderes Signal, wie z.\,B. ein
	Dreieck- oder Rechtecksignal zu erzeugen. Lassen Sie dabei Ihrer Phantasie
	freien Lauf.
\end{problem}

Für ein Rechtecksignal könnte man einen Zähler verwenden, und dann die Ausgabe
umschalten, wenn dieser heruntergezählt ist. Ich möchte hier ein wenig binäre
Logik benutzen und einen überlaufenden Zähler benutzen, jedoch eine der Stellen
als Ausgabe nutzen.

\inputminted[fontsize=\small, linenos]{cpp}{../Prototypen/e.cpp}

\begin{multicols}{9}
	\inputminted[fontsize=\footnotesize]{text}{e.txt}
\end{multicols}

\subsubsection{Bit überprüfen}

\begin{problem}
	Überlegen Sie sich ein Programm, welches in der Lage ist zu erkennen, ob
	das 4.te Bit des B-Registers gesetzt ist. Ist das 4te Bit gesetzt (also
	„1“), so soll das gesamte X-Register der LED Matrix aufleuchten.
\end{problem}

Um ein Bit zu überprüfen, schaue ich mit einer Art Schablone und \txor, ob das
entsprechende Bit gesetzt ist. Mit einem Sprungbefehl, der mit 0 vergleicht,
springe ich an die entsprechende Stelle und setze meine Ausgabe entsprechend.

\inputminted[fontsize=\small, linenos]{cpp}{../Prototypen/f.cpp}

\begin{multicols}{9}
	\inputminted[fontsize=\footnotesize]{text}{f.txt}
\end{multicols}

Diese Ausgabe sind binär nur Einsen (also FF), also wurde das entsprechende Bit
gefunden. Bei FF als Eingabe war dies auch zu erwarten.

\subsubsection{Multiplikation}

\begin{problem}
	Schreiben Sie ein Programm zur Multiplikation zweiter 8-Bit-Zahlen. Der
	Multiplikand und der Multiplikator sollen an den A- und B-Registern
	eingegeben werden. Das Ergebnis (16 Bit) soll von zwei Registern der LED
	Matrix (X und R) angezeigt wwerden. HInweis: Nutzen Sie die
	Doppelgenauigkeits-Arithmetikbefehle.
\end{problem}

Für diese Aufgabe wähle ich einen einfachen Algorithmus, und zwar:
\[
	a \cdot b = \sum_{i = 1}^{a} b
\]

Das Problem ist, dass negative Zahlen so nicht berücksichtigt werden.

\inputminted[fontsize=\small, linenos]{cpp}{../Prototypen/g.cpp}

Die Ausgabe in den zwei Registern ist, wie erwartet:

\begin{multicols}{9}
	\inputminted[fontsize=\footnotesize]{text}{g.txt}
\end{multicols}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  Literatur                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\FloatBarrier
\IfFileExists{\bibliographyfile}{
	\bibliography{\bibliographyfile}
}{}

\end{document}

% vim: spell spelllang=de tw=79
